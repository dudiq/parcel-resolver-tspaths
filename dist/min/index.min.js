"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.trim=exports.trimSlash=exports.trimStar=exports.checkWebpackSpecificImportSyntax=exports.findFileInDirectoryUnknownExt=exports.findFileInDirectory=exports.path=exports.fs=void 0;const plugin_1=require("@parcel/plugin"),utils_1=require("@parcel/utils");function attemptResolve(e,t,r){if(e in t)return t.get(e);for(let r of Object.keys(t)){const o=new RegExp(`^${r.replace("*",".*")}$`,"g");if(e.match(o)){let o=t[r];switch(o.constructor){case String:return o;case Array:return attemptResolveArray(e,r,o)}}}return null}function attemptResolveArray(e,t,r){for(let o of r){let r=e.replace(trimStar(t),trimStar(o)),i=exports.path.resolve(r),n=exports.fs.existsSync(i);if(!n){const e=exports.path.basename(i),t=exports.path.dirname(i);i=findFileInDirectory(t,e),i||(i=findFileInDirectoryUnknownExt(t,e))}if(n=exports.fs.existsSync(i),n){if(exports.fs.statSync(i).isDirectory()&&(i=findFileInDirectory(i),!i))continue;return i}}return null}async function load(e,t,r){let o=await loadTsPaths(e,t,r);return r.verbose({message:`paths loaded: ${JSON.stringify(o)}`}),o}async function loadConfig(e,t){let r=await utils_1.loadConfig(e.inputFS,t,["tsconfig.json","tsconfig.js"],e.projectRoot);if(!r?.config)throw new Error(`Missing or invalid tsconfig.json in project root (${e.projectRoot})`);return r.config}async function loadTsPaths(e,t,r){let o=(await loadConfig(t,e))?.compilerOptions;o||r.verbose({message:"Couldn't find compilerOptions in tsconfig"});let i=o?.baseUrl??"src",n=o?.paths??{},s=new Map;for(let[e,t]of Object.entries(n))switch(t.constructor){case String:s[e]=`${i}${exports.path.sep}${t}`;break;case Array:let r=t.map((e=>`${i}${exports.path.sep}${e}`));s[e]=r;break;default:throw new Error(`Bad path type ${t.constructor}, expected string or string[]`)}return s}function findFileInDirectory(e,t="index",r=["ts","js","tsx","jsx"]){for(let o of r){let r=exports.path.resolve(e,`${t}.${o}`);if(exports.fs.existsSync(r))return r}}function findFileInDirectoryUnknownExt(e,t){if(exports.fs.existsSync(e)){const r=exports.fs.readdirSync(e);for(let o of r)if(exports.path.basename(o,exports.path.extname(o))===t)return exports.path.resolve(e,o)}}function checkWebpackSpecificImportSyntax(e){if(/\S+-loader\S*!\S+/g.test(e.moduleSpecifier))throw new Error(`The import path: ${e.moduleSpecifier} is using webpack specific loader import syntax, which isn't supported by Parcel.`)}function trimStar(e){return trim(e,"*")}function trimSlash(e){return trim(e,exports.path.sep)}function trim(e,t){return e.endsWith(t)&&(e=e.substring(0,e.length-t.length)),e}exports.fs=require("fs"),exports.path=require("path"),exports.default=new plugin_1.Resolver({async resolve({specifier:e,dependency:t,options:r,logger:o}){checkWebpackSpecificImportSyntax(t);let i=t.resolveFrom;if(!i?.match(/\.tsx?$/g))return null;o.verbose({message:`Resolving ${i}`});const n=attemptResolve(e,await load(i,r,o),o);return o.verbose({message:`Result: ${n}`}),n?{filePath:n}:null}}),exports.findFileInDirectory=findFileInDirectory,exports.findFileInDirectoryUnknownExt=findFileInDirectoryUnknownExt,exports.checkWebpackSpecificImportSyntax=checkWebpackSpecificImportSyntax,exports.trimStar=trimStar,exports.trimSlash=trimSlash,exports.trim=trim;